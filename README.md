Игра Жизнь на распределённой памяти
===================================

Запуск
------

Для запуска в интерактивном режиме можно использовать `make run` или `make run-debug`.
В последнем случае программа будет по ходу выполнения выводить некоторое
количество отладочной информации в `debug.log`.

В качестве шортката к типичной схеме "start, run, wait a bit, status, quit"
можно использовать что-то такое:
```
make release  # или debug
./run.sh bin/release <concurrency> <height> <width> <iterations>
# или
./run.sh bin/release <concurrency> <csv input path> '' <iterations>
```

Точный формат ввода поляны из файла можно посмотреть в `inputs/glider.csv`.
Этот же файл содержит простейший глайдер, который каждые 4 такта сдвигается,
не меняя формы.

Чтобы посмотреть на времена работы `run.sh` в зависимости от количества воркеров,
можно использовать `make bench` или `./bench <список количеств воркеров в отдельных аргументах>`.

Практически все синхронизации сделаны на CV, обычный mutex без CV использован
для защиты потока вывода, mutex на основе семафора использован для защиты
количества выполнивших все итерации воркеров.

Ускорение
---------

На моём ноутбуке с увеличением многопоточности ускорение быстро приближается примерно
к 2.25 на 4 воркерах, держится таким до некоторых пор, затем постепенно падает.

На ноде кластера получилось ускорение примерно до 3.88.

Лучшее ускорение получается, если количество воркеров делит высоту таблицы.
Это связано с тем, что я распределяю работу построчно, и если строк поровну,
то и обработка совершается за самое близкое время, и простоев меньше.

По всей видимости, лучшего ускорения не получается, потому что воркеры тратят время
на синхронизацию и вынуждены всё время поджидать друг друга, делая много системных
вызовов, дорогих по сравнению с чистыми вычислениями.

Ускорение падает при большом количестве воркеров, потому что когда потоков исполнения
много больше, чем исполняющих устройств, много времени тратится на постоянную
приостановку и пробуждение.

Вероятно, железо и ОС кластерной ноды более предназначены для многопоточности.


Попытка оптимизации
-------------------

В последних коммитах можно увидеть попытку оптимизировать воркеров так,
что очередная сторона считается уже тогда, когда закончил соответствующий сосед,
а не тогда, когда закончили все соседи. Это позволило улучшить ускорение на ноде
кластера до примерно 3.95 (при запуске через `srun -n 1 ./bench.sh 1 4`).
Кроме того, если раньше при одновременном запуске на одной задаче 200
потоков-воркеров производительность падала в два раза по сравнению
с четырьмя воркерами, теперь производительность остаётся прежней.

Видимо, так происходит благодаря уменьшению накопления ожидания, которое мы
обсуждали на сдаче.

